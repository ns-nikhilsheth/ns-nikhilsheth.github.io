<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Scale of the Universe 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        #scale-label {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }
        #scale-value {
            font-size: 1rem;
            opacity: 0.7;
            margin-bottom: 20px;
            font-family: monospace;
        }
        #slider-container {
            pointer-events: auto;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 300px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 0 10px white;
        }
        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="instructions">Scroll or Drag Slider to Zoom</div>

<div id="ui-container">
    <div id="scale-label">Loading...</div>
    <div id="scale-value">1 meter</div>
    <div id="slider-container">
        <input type="range" id="zoomSlider" min="-16" max="22" step="0.01" value="0">
    </div>
</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // --- CONFIGURATION ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.001, 1000);
    camera.position.z = 2; // Fixed camera position

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 3, 100);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    const sunLight = new THREE.PointLight(0xffaa00, 5, 100); // Specific for Sun
    sunLight.visible = false;
    scene.add(sunLight);

    // --- DATA: POWERS OF 10 (METERS) ---
    // We render objects at scale 1.0, then scale them based on the zoom level
    const objectsData = [
        { name: "Proton", power: -15, type: 'proton', color: 0xff3333 },
        { name: "Hydrogen Atom", power: -10, type: 'atom', color: 0x3388ff },
        { name: "DNA Helix", power: -8.5, type: 'dna', color: 0xdddddd },
        { name: "Virus", power: -7, type: 'virus', color: 0x88ff88 },
        { name: "Sand Grain", power: -3, type: 'sand', color: 0xccaa88 },
        { name: "Beach Ball", power: -0.5, type: 'ball', color: 0xff00cc },
        { name: "Human", power: 0, type: 'human', color: 0xffccaa }, 
        { name: "Earth", power: 7.1, type: 'earth', color: 0x2233ff },
        { name: "Sun", power: 9.2, type: 'sun', color: 0xffaa00 },
        { name: "Solar System", power: 12.5, type: 'solar', color: 0xffffff },
        { name: "Milky Way Galaxy", power: 20.8, type: 'galaxy', color: 0xaa88ff }
    ];

    const meshGroup = new THREE.Group();
    scene.add(meshGroup);

    // --- GEOMETRY GENERATORS ---
    
    function createProton() {
        const g = new THREE.Group();
        const sphere = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1, 2),
            new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                emissive: 0x550000,
                roughness: 0.4 
            })
        );
        g.add(sphere);
        // Quarks
        for(let i=0; i<3; i++) {
            const q = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color:0xffff00}));
            q.position.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5);
            g.add(q);
        }
        return g;
    }

    function createAtom() {
        const g = new THREE.Group();
        // Nucleus
        const nuc = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), new THREE.MeshStandardMaterial({color:0xff0000}));
        g.add(nuc);
        // Electrons
        const ringGeo = new THREE.TorusGeometry(1, 0.02, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x44aaff, transparent: true, opacity: 0.6 });
        
        const r1 = new THREE.Mesh(ringGeo, ringMat);
        r1.rotation.x = Math.PI / 2;
        
        const r2 = new THREE.Mesh(ringGeo, ringMat);
        r2.rotation.y = Math.PI / 2;
        
        g.add(r1, r2);
        
        const electron = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({color:0x00ffff}));
        electron.position.x = 1;
        g.add(electron);
        
        g.userData.animate = (time) => {
            g.rotation.z = time * 0.5;
            g.rotation.x = time * 0.2;
        };
        return g;
    }

    function createDNA() {
        const g = new THREE.Group();
        const geometry = new THREE.BufferGeometry();
        const points = [];
        const colors = [];
        const color1 = new THREE.Color(0xff00ff);
        const color2 = new THREE.Color(0x00ffff);

        for (let i = 0; i < 100; i++) {
            const angle = i * 0.5;
            const y = (i - 50) * 0.1;
            const x1 = Math.cos(angle) * 0.5;
            const z1 = Math.sin(angle) * 0.5;
            points.push(x1, y, z1);
            colors.push(color1.r, color1.g, color1.b);
            
            const x2 = Math.cos(angle + Math.PI) * 0.5;
            const z2 = Math.sin(angle + Math.PI) * 0.5;
            points.push(x2, y, z2);
            colors.push(color2.r, color2.g, color2.b);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({ size: 0.1, vertexColors: true });
        const mesh = new THREE.Points(geometry, material);
        g.add(mesh);
        
        // Connect rungs
        const rungs = new THREE.Group();
        for(let i=0; i<100; i+=2) {
           const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshBasicMaterial({color:0xffffff}));
           bar.position.y = (i - 50) * 0.1;
           bar.rotation.y = -i * 0.5; // Twist to match helix
           bar.rotation.z = Math.PI / 2;
           rungs.add(bar);
        }
        // g.add(rungs); // omitting rungs to save polygons/complexity, points look cleaner
        
        g.userData.animate = (time) => {
            g.rotation.y = time;
        };
        return g;
    }

    function createBall() {
        const geo = new THREE.SphereGeometry(1, 32, 32);
        // Simple striped texture trick using vertex colors or just a wireframe overlay
        const mat = new THREE.MeshStandardMaterial({ color: 0xff00cc, roughness: 0.2 });
        const mesh = new THREE.Mesh(geo, mat);
        
        const stripe = new THREE.Mesh(new THREE.TorusGeometry(1.01, 0.1, 16, 100), new THREE.MeshBasicMaterial({color:0xffffff}));
        mesh.add(stripe);
        const stripe2 = stripe.clone();
        stripe2.rotation.x = Math.PI/2;
        mesh.add(stripe2);

        return mesh;
    }

    function createEarth() {
        const g = new THREE.Group();
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x1122ff, 
            roughness: 0.8,
            metalness: 0.1
        });
        const earth = new THREE.Mesh(geometry, material);
        
        // Atmosphere
        const atmoGeo = new THREE.SphereGeometry(1.2, 32, 32);
        const atmoMat = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.1, side: THREE.BackSide });
        const atmo = new THREE.Mesh(atmoGeo, atmoMat);
        
        // Simple continents (represented by noise-like shapes could be complex, using wireframe for tech feel)
        const wire = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1.01, 3),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.3 })
        );

        g.add(earth);
        g.add(atmo);
        g.add(wire);
        
        g.userData.animate = (time) => {
            g.rotation.y = time * 0.1;
        };
        return g;
    }

    function createSun() {
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const mesh = new THREE.Mesh(geometry, material);
        
        // Corona
        const corona = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.3 })
        );
        mesh.add(corona);
        
        return mesh;
    }

    function createSolarSystem() {
        const g = new THREE.Group();
        // Sun marker
        const sun = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0xffaa00}));
        g.add(sun);
        
        // Orbits
        const orbitMat = new THREE.LineBasicMaterial({ color: 0x555555 });
        [0.4, 0.7, 1.0, 1.5, 5.2].forEach(radius => {
            const points = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                points.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geo, orbitMat);
            g.add(line);
        });
        
        g.userData.animate = (time) => {
            g.rotation.y = time * 0.05;
        };
        return g;
    }

    function createGalaxy() {
        const g = new THREE.Group();
        const particles = 5000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        
        const colorInside = new THREE.Color(0xffaa55);
        const colorOutside = new THREE.Color(0x5555ff);

        for (let i = 0; i < particles; i++) {
            // Spiral distribution
            const radius = Math.random() * 2;
            const spinAngle = radius * 5;
            const branchAngle = (i % 3) * ((Math.PI * 2) / 3);
            
            const x = Math.cos(spinAngle + branchAngle) * radius + (Math.random()-0.5)*0.2;
            const y = (Math.random() - 0.5) * 0.1 * (2 - radius); // Thinner at edges
            const z = Math.sin(spinAngle + branchAngle) * radius + (Math.random()-0.5)*0.2;
            
            positions.push(x, y, z);
            
            const mixedColor = colorInside.clone().lerp(colorOutside, radius / 2);
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ size: 0.02, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false });
        const mesh = new THREE.Points(geometry, material);
        g.add(mesh);
        
        g.userData.animate = (time) => {
            g.rotation.y = time * 0.05;
        };

        return g;
    }

    // --- INITIALIZATION ---
    
    // Create meshes for each object type
    objectsData.forEach(obj => {
        let mesh;
        switch(obj.type) {
            case 'proton': mesh = createProton(); break;
            case 'atom': mesh = createAtom(); break;
            case 'dna': mesh = createDNA(); break;
            case 'virus': mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), new THREE.MeshStandardMaterial({color: obj.color, flatShading: true})); break;
            case 'sand': mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(1), new THREE.MeshStandardMaterial({color: obj.color, roughness: 1})); break;
            case 'ball': mesh = createBall(); break;
            case 'human': mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.3), new THREE.MeshStandardMaterial({color: obj.color})); break; // Abstract human
            case 'earth': mesh = createEarth(); break;
            case 'sun': mesh = createSun(); break;
            case 'solar': mesh = createSolarSystem(); break;
            case 'galaxy': mesh = createGalaxy(); break;
            default: mesh = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({color: obj.color}));
        }
        
        obj.mesh = mesh;
        scene.add(mesh);
    });

    // --- STARFIELD BACKGROUND ---
    const starGeo = new THREE.BufferGeometry();
    const starPos = [];
    for(let i=0; i<2000; i++) {
        starPos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*100 - 50);
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    const starMesh = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.1}));
    scene.add(starMesh);


    // --- MAIN LOOP ---
    
    const slider = document.getElementById('zoomSlider');
    const label = document.getElementById('scale-label');
    const valueLabel = document.getElementById('scale-value');
    
    let currentZoom = parseFloat(slider.value);

    // Scroll handling
    window.addEventListener('wheel', (e) => {
        let val = parseFloat(slider.value);
        val -= e.deltaY * 0.005; 
        // Clamp
        if (val < -16) val = -16;
        if (val > 22) val = 22;
        slider.value = val;
    });

    function formatPowerOf10(power) {
        if (power >= 9) return (Math.pow(10, power-9)).toFixed(1) + " Billion meters";
        if (power >= 6) return (Math.pow(10, power-6)).toFixed(1) + " Million meters";
        if (power >= 3) return (Math.pow(10, power-3)).toFixed(1) + " Kilometers";
        if (power >= 0) return Math.pow(10, power).toFixed(2) + " Meters";
        if (power >= -3) return (Math.pow(10, power+3)).toFixed(2) + " Millimeters";
        if (power >= -6) return (Math.pow(10, power+6)).toFixed(2) + " Micrometers";
        if (power >= -9) return (Math.pow(10, power+9)).toFixed(2) + " Nanometers";
        return `10^${Math.floor(power)} meters`;
    }

    function animate(time) {
        requestAnimationFrame(animate);
        const t = time * 0.001;
        
        currentZoom = parseFloat(slider.value);
        valueLabel.innerText = formatPowerOf10(currentZoom);
        
        // Find closest object for label
        let closestObj = objectsData[0];
        let minDiff = 1000;

        // Logic: Object Scale = 1 * 10 ^ (ObjectPower - Zoom)
        // If Zoom == ObjectPower, Scale is 1 (Standard Unit)
        
        objectsData.forEach(obj => {
            const diff = obj.power - currentZoom;
            
            // We want objects to be visible when they are roughly within standard view range
            // Let's say visible scale is between 0.001 and 50
            
            const scale = Math.pow(10, diff);
            
            if (scale > 0.0001 && scale < 1000) {
                obj.mesh.visible = true;
                obj.mesh.scale.setScalar(scale);
                
                // Fade in/out based on log distance
                // Peak visibility when diff is close to 0
                // Fade out as diff goes to -3 or +3
                let opacity = 1 - (Math.abs(diff) / 3);
                if (opacity < 0) opacity = 0;
                
                // Traverse and set opacity for all materials in the group
                obj.mesh.traverse((child) => {
                   if (child.isMesh) {
                       if (child.material.transparent) {
                           // Keep existing transparency relative
                           child.material.opacity = opacity * 0.8; 
                       } else {
                           // Hack to make standard materials fade: enable transparent
                           if (opacity < 0.95) {
                               child.material.transparent = true;
                               child.material.opacity = opacity;
                           } else {
                               child.material.transparent = false;
                           }
                       }
                   } 
                });
            } else {
                obj.mesh.visible = false;
            }

            // Label Logic
            if (Math.abs(diff) < minDiff) {
                minDiff = Math.abs(diff);
                closestObj = obj;
            }
            
            // Run internal animations
            if (obj.mesh.userData.animate) {
                obj.mesh.userData.animate(t);
            }
        });
        
        label.innerText = closestObj.name;
        
        // Special lighting for Sun
        if (closestObj.name === "Sun" && minDiff < 1) {
            sunLight.visible = true;
            ambientLight.intensity = 0.5;
        } else {
            sunLight.visible = false;
            ambientLight.intensity = 2;
        }

        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(0);
</script>
</body>
</html>
